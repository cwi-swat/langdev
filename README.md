## LangDev Meetup 14-15 November 2023

The Language Developer’s Meetup (LangDev) is an informal meeting where language engineering enthusiasts from both industry and academia can come together to discuss the state-of-the-art and state-of-the-practice of language engineering.  


### Location

Rijkskantoor de Knoop Croeselaan 14, 3521 CA Utrecht, The Netherlands

Click [here](https://goo.gl/maps/ZwzBaGej7WVeb6Pt7) for Google Maps. 

Rijkskantoor de Knoop is close to Utrecht central station (5 minutes walking distance).

Registration takes place directly on site. Please have your ticket and passport or European identification card at hand. Due to a strict policy in buildings of the public administration, a ticket with your full name as shown on your passport or European identification card is required.

### Registration

Tickets are free, but in limited amount available at **[this link](https://www.eventbrite.com/e/langdev-2023-tickets-690721134507?aff=oddtdtcreator)**. Registration is **strictly** required. Please use your full name as shown on your passport.

Registration is possible until **9th of November**.

### Important Dates 
* **04.08.2023**: Call for Presentations 
* **15.09.2023**: Submission Deadline
* **15.10.2023**: Acceptance Notification
* **09.11.2023**: Registration Deadline
* **14.11.2023-15.11.2023**: LangDev'23 Meeting

### Preliminary Schedule

<style>
    table.schedule {
        border-collapse: collapse;
        border: 1px solid;
        display: table;
        width: 100%;
    }

    table.schedule:nth-child(even) {
        margin-top: 20px;
    }

    table.schedule td:nth-child(1) {
        width: 50px;
        text-align: right;
    }

    table.schedule td:nth-child(2) {
        width: 60%;
    }

    table.schedule td:nth-child(3) {
        width: 30%;
    }

    table.schedule th, td {
        border: 1px solid black;
        text-align: left;
        vertical-align: center;
        padding: 8px;
    }

    table.schedule tr.day {
        background-color: midnightblue;
    }

    table.schedule tr.day td {
        color: white;
        font-weight: bold;
        text-align: left;
    }

    table.schedule tr.break {
        background-color: lightgray;
        color: black;
    }

    table.schedule tr.break td:nth-child(2) {
        text-align: center;
    }
</style>


<table class="schedule" markdown="0">
    <tr class="day">
        <td colspan="3">Tuesday, November 14</td>
    </tr>
    <tr>
        <td>8:30</td>
        <td colspan="2">Registration</td>
    </tr>
    <tr>
        <td>9:00</td>
        <td colspan="2">Welcome</td>
    </tr>
    <tr>
        <td>9:30</td>
        <td>
          <a href="#framing-debug-protocols-to-hotwire-probes-by-tijs-van-der-storm">Framing Debug Protocols to Hotwire Probes</a>
        </td>
        <td>Tijs van der Storm</td>
    </tr>
    <tr>
        <td>10:00</td>
        <td>
          <a href="#now-witness-the-power-of-fully-operational-partial-evaluation-by-meinte-boersma">Now witness the power of fully operational partial evaluation!</a>
        </td>
        <td>Meinte Boersma</td>
    </tr>
    <tr class="break">
        <td>10:30</td>
        <td colspan="2">Coffee break</td>
    </tr>
    <tr>
        <td>11:00</td>
        <td>
          <a href="#projectional-forms-by-herman-peeren">Projectional Forms</a>
        </td>
        <td>Herman Peeren</td>
    </tr>
    <tr>
        <td>11:30</td>
        <td>
          <a href="#your-own-language-design-with-langium-execute-fast-with-llvm-by-irina-artemeva">Your Own Language: design with Langium, execute fast with LLVM</a>
        </td>
        <td>Irina Artemeva</td>
    </tr>
    <tr>
        <td>12:00</td>
        <td>
          <a href="#the-starlasu-method-for-writing-parsers-by-federico-tomassetti">The StarLasu method for writing parsers</a>
        </td>
        <td>Federico Tomassetti</td>
    </tr>
    <tr class="break">
        <td>12:30</td>
        <td colspan="2">Lunch</td>
    </tr>
    <tr>
        <td>14:00</td>
        <td>
          <a href="#incremental-type-checking-for-free-by-aron-zwaan">Incremental Type-Checking for Free</a>
        </td>
        <td>Aron Zwaan</td>
    </tr>
    <tr>
        <td>14:30</td>
        <td>
          <a href="#make-models-available-on-the-web-through-modelix-practical-design-considerations-building-blocks-and-samples-by-norman-köster">Make models available on the web through modelix: Practical design considerations, building blocks and samples</a>
        </td>
        <td>Norman Köster</td>
    </tr>
    <tr>
        <td>15:00</td>
        <td>
          <a href="#compositional-engineering-of-dsls-for-assistive-systems-by-judith-michael">Compositional Engineering of DSLs for Assistive Systems</a>
        </td>
        <td>Judith Michael</td>
    </tr>
    <tr class="break">
        <td>15:30</td>
        <td colspan="2">Coffee break</td>
    </tr>
    <tr>
        <td>16:00</td>
        <td>
          <a href="#the-revival-of-dr-ambiguity-requirements-design-and-implementation-of-a-grammar-engineering-environment-by-jurgen-vinju">The Revival of Dr Ambiguity: requirements, design, and implementation of a grammar engineering environment</a>
        </td>
        <td>Jurgen Vinju</td>
    </tr>
    <tr>
        <td>16:30</td>
        <td>
          <a href="#eclipse-sirius-web-a-low-code-and-cloud-native-language-workbench-for-graphical-modeling-dsls-by-théo-giraudet">Eclipse Sirius Web: A low code and cloud native language workbench for graphical modeling DSLs</a>
        </td>
        <td>Théo Giraudet</td>
    </tr>
    <tr>
        <td>17:00</td>
        <td>
          <a href="#orca-web-dsl-for-editing-container-orchestration-configurations-by-pedro-j-molina">Orca: Web DSL for editing Container Orchestration Configurations</a>
        </td>
        <td>Pedro Molina</td>
    </tr>
</table>

<table class="schedule" markdown="0">
    <tr class="day">
        <td colspan="3">Wednessday, November 15</td>
    </tr>
    <tr>
        <td>8:30</td>
        <td colspan="2">Registration</td>
    </tr>
    <tr>
        <td>9:00</td>
        <td>
          <a href="#cinco-cloud--the-next-generation-of-graphical-language-engineering-by-daniel-busch">Cinco Cloud – The Next Generation of Graphical Language Engineering</a>
        </td>
        <td>Daniel Busch</td>
    </tr>
    <tr>
        <td>9:30</td>
        <td>
          <a href="#implementing-symbol-resolution-in-starlasu-by-lorenzo-addazi">Implementing Symbol Resolution in StarLasu</a>
        </td>
        <td>Lorenzo Addazi</td>
    </tr>
    <tr>
        <td>10:00</td>
        <td>
          <a href="#building-extendible-translators-by-gert-veldhuijzen-van-zanten">Building extendible translators</a>
        </td>
        <td>Gert Veldhuijzen van Zanten</td>
    </tr>
    <tr class="break">
        <td>10:30</td>
        <td colspan="2">Coffee break</td>
    </tr>
    <tr>
        <td>11:00</td>
        <td>
          <a href="#the-lionweb-initiative-by-niko-stotz-and-jos-warmer">LionWeb Initiative</a>
        </td>
        <td>Niko Stotz and Jos Warmer</td>
    </tr>
    <tr>
        <td>11:30</td>
        <td>
          <a href="#enabling-technology-for-live-programming-by-riemer-van-rozen">Enabling Technology for Live Programming</a>
        </td>
        <td>Riemer van Rozen</td>
    </tr>
    <tr>
        <td>12:00</td>
        <td>
          <a href="#alef-from-tax-law-to-code-by-arjan-oortgiese">ALEF: From Tax law to code</a>
        </td>
        <td>Arjan Oortgiese</td>
    </tr>
    <tr class="break">
        <td>12:30</td>
        <td colspan="2">Lunch</td>
    </tr>
    <tr>
        <td>14:00</td>
        <td>
          <a href="#a-case-for-an-open-protocol-for-collaboration-by-mark-sujew">A Case for an Open Protocol for Collaboration</a>
        </td>
        <td>Mark Sujew</td>
    </tr>
    <tr>
        <td>14:30</td>
        <td>
          <a href="#server-side-architecture-for-reactive-analysis-of-domain-models-by-radimir-sorokin">Server-side architecture for reactive analysis of domain models</a>
        </td>
        <td>Radimir Sorokin</td>
    </tr>
    <tr>
        <td>15:00</td>
        <td>
          <a href="#leveraging-machine-learning-for-python-version-identification-by-vadim-zaytsev">Leveraging Machine Learning for Python Version Identification</a>
        </td>
        <td>Vadim Zaytsev</td>
    </tr>
    <tr class="break">
        <td>15:30</td>
        <td colspan="2">Coffee break</td>
    </tr>
    <tr>
        <td>16:00</td>
        <td>
          <a href="#human-centred-explanation-of-rule-based-systems-in-the-legal-domain-by-suzan-zuurmond">Human-centred explanation of rule-based systems in the legal domain</a>
        </td>
        <td>Suzan Zuurmond</td>
    </tr>
    <tr>
        <td>16:30</td>
        <td>
          <a href="#transformations-to-map-concrete-and-abstract-syntaxes-in-mps-by-wim-bast">Transformations to map concrete and abstract syntaxes in MPS</a>
        </td>
        <td>Wim Bast</td>
    </tr>
    <tr>
        <td>17:00</td>
        <td colspan="2">Closing</td>
    </tr>
</table>

### Accepted Talks and Abstracts

<style markdown="0">
h4 span.presenter {
    font-weight: normal;
}
</style>

#### Framing Debug Protocols to Hotwire Probes <span class="presenter">by Tijs van der Storm</span> 

Live probes provide developers continuous insight in the run-time evolution of the value
of local variables of methods and functions. Originally introduced (and gone viral)
through Bret Victor’s presentation “Inventing on Principle”, probes have become a form
of live, example-based programming, that has received considerable research attention.
Nevertheless, existing approaches are bespoke, or depend on specific language runtimes.
In this talk we will demonstrate how debug protocols can be used to realize probes. We
show how to engineer probes with only modest efforts for mainstream languages, such as
C, Java, Javascript and Python, and sketch directions for future work, and what probes
could mean for domain-specific languages and end-user programming.

#### Now witness the power of fully operational partial evaluation! <span class="presenter">by Meinte Boersma</span>

Partial evaluation is a technique to “run” a program against input that's only partially known. The goal of this concept could be to optimize a program, or to help with reasoning about its behavior without using a debugger. The use case that I'll be using to demonstrate the concept with is inspired by analysis of business rules for the EU DCC (the “international COVID-19 QR code”).

During this talk, you'll learn about:

* How to modify existing language implementations for partial evaluation
* Prerequisites for being able to implement partial evaluation
* A monadic technique for tracing evaluation, necessary to meaningfully interpret results

Even though this technique isn't entirely new, the influence of FP on the design of DSLs has made it interesting again. I'll live-demo the implementation of partial evaluation in a tiny language, using a TypeScript-based development environment, and according to the following steps:

* Outline the implementation of a tiny, interpreted language 
* Extend the language with the concept of unknowns (“variables”) 
* Adapt the interpretation with traceability

(I might also use Freon.)

#### Projectional Forms <span class="presenter">by Herman Peeren</span>

The basic idea of “Projectional Forms” is very simple: use HTML form elements instead of text in an editor to get information into an AST. Text input boxes, dropdown select boxes, check boxes, radio buttons etc.

From the early days of the World Wide Web on, form elements were the way to interact with an HTML page. In modern web-applications form elements are still widely used to gather user input. Forms have evolved and many packages and frameworks offer more elaborate possibilities out of the box, built on top of the same old basic form tags: custom fields, (repeating) sub-forms, form validation, easy creation, JSON output etc. The possibilities are endless. An important advantage of the use of form elements in online applications is: people are used to them and don't have to learn something new. It is easier to use than a text based editor.

I will demo the use of projectional forms on the hand of the “Extension Generator” I'm working on at the moment. First presentation was on Dutch JoomlaDays in May (which were at the same time as the MPS Community Meetup this year). It uses forms on the M1-level to create complete and working online applications, like e-commerce or a booking system. It was based on earlier work in Xtext that was later ported to MPS. In this Extension Generator the AST is filled (online) using HTML form elements, that were static, predefined. The applications are mainly generated from the AST using templates.

This summer I've been working on the M2-level: making forms that dynamically define forms. This is in fact defining DSLs! This definition of forms is again done using HTML form elements, online. I've used LionWeb as the basic structure on the M3-level and am now working on import and export from and to the LionWeb Serialization Format.

Next step will be to define generators using a “forms-language” (beside the use of templates). Main inspiration for this part are MPS' model-to-model transformations. A presentation about that is planned for medio October.

Although still work in progress, I can demo the concept of Projectional Forms with this practical Extension Generator and show the limitless possibilities of simple HTML form elements as a medium for projectional editing and language definition. In many cases it can be an interesting alternative for traditional code in text format.

#### Your Own Language: design with Langium, execute fast with LLVM <span class="presenter">by Irina Artemeva</span>

Creating a domain-specific language (DSL) tailored to a specific domain has advantages over using general-purpose programming languages (GPLs). Solving particular problems with DSLs can be easier and more effective. With Langium, implementing your own DSL is a simple task. However, what if your DSL requires the same performance or platform flexibility as a GPL? Many GPLs use the LLVM infrastructure to compile to native code and achieve high execution speeds. You can do the same for your DSL!

In this presentation, you will learn how to use LLVM to make your DSL, written in Langium, run faster. We will cover the following topics:

* Injecting LLVM into a Langium project
* Obtaining LLVM IR from your DSL 
* Accelerating the program in your language by applying LLVM optimizations 
* Compiling your DSL into native code for different architectures 

Finally, we will compare two approaches for making your DSL executable:

* Transforming a DSL program into a GPL to use the capabilities of that GPL
* Transforming a DSL program into LLVM IR to take advantage of the LLVM infrastructure."

#### The StarLasu method for writing parsers <span class="presenter">by Federico Tomassetti</span>

In this presentation we present the results of our reflections on building the best parsers we can. This means producing quality models, making them easy to consume by different users, testing them thoroughly, and documenting them appropriately. It also means ensuring that the process to develop them is as pleasant as possible. The result of these reflections is the StarLasu method and the supporting libraries and tools that make it possible to apply this method conveniently.

We hope that sharing this work at LangDev will help us validate it with this audience of experts and identify how we can improve it.

Among other points we will also discuss how the compatibility with LionWeb could play a role in making parsers built with this method more valuable for a larger audience. Demo outline: Most of the presentation will be covered by slides, but I also plan to introduce very short demos to demonstrate our testing tool, our parsing tool, and our documentation tool. If needed for the evaluation I can provide some preliminary screenshots and a more detailed outline.

#### Incremental Type-Checking for Free <span class="presenter">by Aron Zwaan</span>

Fast analysis response times in IDEs are essential for a good editor experience.
Incremental type-checking can provide that in a scalable fashion.
However, existing techniques are not reusable between languages.
Moreover, mutual and dynamic dependencies preclude traditional approaches to incrementally. This makes finding automatic approaches to incremental type-checking a challenging but important open question.

In this talk, I'll present a technique that automatically derives incremental type-checkers from type system specifications using Scope Graphs (a generic model of name binding and resolution).
We use name resolution queries in scope graphs to derive dependencies between compilation units.
A novel query confirmation algorithm finds queries for which the answer changed due to an edit in the program.
In this way, we can automatically incrementalize a large class of type checkers.

#### Make models available on the web through modelix: Practical design considerations, building blocks and samples <span class="presenter">by Norman Köster</span>

We present a practical introduction to the modelix platform via the new modelix samples [1,2]. We show how we envision the application of the platform to bring your (meta-)models to the web. This talk will walk you through a selection of use cases which require distinct domain expert facing tools - all based on the same meta-models - integrated into the same system, and with real-time collaboration features. The live demonstration is accompanied by details about the corresponding system architectures and technical details realising these collaborative tools. Our goal is to inspire language engineers and developers to extrapolate from the presented use cases and envision potential applications for their own projects. Our samples are freely available and can be reproduced easily. Extensions can be made directly to the concise and fully self-contained project, which allows for quick testing and idea verification using the modelix platform.

1. [https://modelix.org/](https://modelix.org/)
2. [https://github.com/modelix/modelix-samples](https://github.com/modelix/modelix-samples)

#### Compositional Engineering of DSLs for Assistive Systems <span class="presenter">by Judith Michael</span>

The compositional engineering of DSLs for the creation of assistive systems requires to combine models representing different perspectives, e.g., performed tasks, needed resources, spatial relations, surrounding contexts, or graphical user interfaces. In this talk, I will provide insights into how we have created a language family to cover these perspectives by using different language composition methods, reusing existing language components as well as creating new DSLs. The new DSLs are designed to be easy to understand for people without programming skills but powerful enough to describe tasks and related resources in a detailed way for generation purposes. We show their application in an assistive system to support processes in a smart kitchen. Moreover, we discuss how to evolve the languages to be usable for further domains, and how to integrate these DSLs into a low-code platform.

#### The Revival of Dr Ambiguity: requirements, design, and implementation of a grammar engineering environment <span class="presenter">by Jurgen Vinju</span>

In this talk, we demonstrate an interactive environment for the design, creation, maintenance, and testing of context-free grammars
for programming languages, modeling languages, and other domain-specific languages. The property that
Dr. Ambiguity focuses on is "ambiguity". Fast non-deterministic, context-free general, parsing allows for simple (not "factored") grammar
rules that are easy to compose and extend. This leads to natural grammars for embedded languages (COBOL+SQL+CICS for example),
but also for managing many language dialects (think IBM COBOL vs MicroFocus COBOL). However, non- deterministic parsers may also produce
ambiguous trees. Dr. Ambiguity helps to detect these ambiguities at an early stage, to diagnose them when
they happen, to remedy the situation by declarative disambiguation, and to test for regressions during grammar maintenance.
We discuss the motivation, design, and inner workings of the algorithms that support the user in their grammar engineering tasks, and we
take Dr. Ambiguity for a live test drive.

#### Eclipse Sirius Web: A low code and cloud native language workbench for graphical modeling DSLs <span class="presenter">by Théo Giraudet</span>

Eclipse Sirius is an open source project dedicated to the design and utilization of graphical modeling languages with a low code approach. This project started in 2007 in collaboration with Thales through the first implementation Eclipse Sirius Desktop, an Eclipse-based language workbench. For a decade, Sirius Desktop has been used for numerous desktop projects but these required installation on the users’ machines. To simplify the deployment phase, we proposed in 2019 the first release of a new cloud-native implementation of Sirius named Eclipse Sirius Web, based on the same principles of Sirius Desktop and refined with our experience. In this talk, we will look at the main principles of the Sirius project before focusing on Sirius Web. We will finish with a demo of Sirius Web where we will implement in an iterative way a small DSL with both diagram and form representation.

#### Orca: Web DSL for editing Container Orchestration Configurations <span class="presenter">by Pedro J. Molina</span>

Software containers are gaining momentum as the preferred way to distribute, deploy, & operate software.
Main tools for dealing with container description and orchestration are YAML based (text-based tools) with examples like Docker Compose and Kubernetes.
Orca ([https://orca-tool.com](https://orca-tool.com)) is a new graphical editor built for the web (using Angular + D3 + SVG) that allows users to create Docker Compose container configurations in a graphical way.
Features like import/export to docker-compose, AI Assistant (ChatGTP enabled), model validator, & cloud storage are provided.
Following a complete No-code approach, this graphical DSL removes entry-barriers for non-technical users to learn about & understand complex container configurations.
During the talk, a live-demo will be delivered.

##### Brief demo outline:

1. Explain the building blocks available. 
2. Import a docker-compose.yaml file.
3. Edit capabilities.
4. Validation capabilities.
5. Export capabilities. 6. AI Assistant.

#### Cinco Cloud – The Next Generation of Graphical Language Engineering <span class="presenter">by Daniel Busch</span>

We present Cinco Cloud, a holistic web-based language engineering environment that seamlessly aligns the entire process from the meta-modeling of graphical domain-specific languages, via application modeling in corresponding integrated modeling environments, to the deployment of the final product through CI/CD pipelines using Git repository platform integrations. Cinco Cloud supports a role-specific access management in order to organize the collaborative modeling involving stakeholders of different expertise without any installation requirements. The presentation illustrates the interplay of all the required steps with a concrete application example.

#### Implementing Symbol Resolution in StarLasu <span class="presenter">by Lorenzo Addazi</span>

We know that symbol resolution is a necessary step when performing non-trivial code analysis. There are various approaches to implement it and designing a notation to express its rules as easily and understandably as possible remains a challenge. In this presentation, we share our experience in working on a symbol resolution framework to be used in StarLasu - a methodology promoting the development of language-processing tools, e.g. transpilers, compilers, interpreters and static analysis tools, as configurable pipelines through a collection of open- source runtime libraries in various programming languages, e.g. Kotlin, Python, Typescript and C#. First, we are going to illustrate how symbol resolvers can be implemented in StarLasu, i.e. how to represent references among nodes, how to specify language-specific resolution rules and what kind of support is provided. Then, a short open-source demo illustrating a symbol resolver for a simple entity language implemented using Kolasu in Kotlin will be provided.

#### Building extendible translators <span class="presenter">by Gert Veldhuijzen van Zanten</span>

We will describe how extendible translators can be build using a language that incorporated polymorphic dispatch and memoization.
Polymorphic dispatch helps simplifying case analysis and memoization helps preventing cyclic visits and greatly simpifies reference resolving between target nodes. Translators can easiy be extended to add additional cases for instance for language extensions.
We will show how the language can be used for writing extendible interpreters, migrations, type checkers, and desugarings.
We will also show some of the technniques used to implement the translator language.

#### The LionWeb Initiative <span class="presenter">by Niko Stotz and Jos Warmer</span>

The LionWeb initiative defines protocols for communication between participating software components such as repositories, editors, and other clients. It facilitates the community-based development and reuse of language engineering and modeling tools on the web. In this talk, we’ll introduce LionWeb with a particular focus on integrating different technologies.
We’ll start with an overview of LionWeb as a whole, our perspective on web-based modeling tools, why we’re working on it, who is involved, a little bit of history, and a sneak peek at some of the tools that are being developed in the vicinity. Then we’ll show how to exchange M2 and M1 models between different technologies and programming languages like MPS/Java, StarLasu/Kotlin, EMF/Xtend, and Freon/TypeScript. We’ll include projectional editors, parsers, fat clients, web environments, and more. We’ll wrap up the talk with a review of what we have achieved so far and an outline of concrete steps planned for 2024.
Last but not least, we’ll discuss why you should participate in the initiative.

#### Enabling Technology for Live Programming <span class="presenter">by Riemer van Rozen</span>

Live programming brings code to life with immediate and continuous feedback. To enjoy its benefits, programmers need powerful languages and live programming environments for understanding the effects of code modifications on running programs. Our focus is on developing the necessary technology to construct these languages. In this talk, we will delve into two key technologies for creating Domain- Specific Languages (DSLs) equipped with interface- and feedback-mechanisms that facilitate live programming. Specifically, we combine Cascade, a meta-language for change, cause and effect [1] with Godot, a modern open source game engine [2]. We illustrate how to engineer a visual live programming environment for Machinations, a DSL for game design. We demonstrate that Vie, a tiny live game engine, enables simultaneously designing mechanisms and play-testing running game prototypes.

1. Riemer van Rozen. 2023. Cascade: A Meta-Language for Change, Cause and Effect. In Conference on Software Language Engineering (SLE ’23).
2. Riemer van Rozen. 2023. Game Engine Wizardry for Programming Mischief. In Workshop on Programming Abstractions and Interactive Notations, Tools, and Environments (PAINT ’23).

#### ALEF: From Tax law to code <span class="presenter">by Arjan Oortgiese</span>

In this talk we want to demonstrate how rule analysts can enter and check the validity of rules. The tool ALEF (Agile Law Execution Factory) is developed by the Dutch Tax Office to support the process of translating law to software in an agile and technology independent way. Rule analysts specify the meaning of the law in a CNL (Controlled Natural Language) that is called Regelspraak. This specification is transformed to products like:

* Decision services
* Documentation for verification
* Decision transparency (work in progress)

We want to explain the usage of MDSE (Model Driven Software Engineering) and the benefits. We will also demo the key features of ALEF like editing the model, the interpreter for testing the model and the code generator for the decision services.

#### A Case for an Open Protocol for Collaboration <span class="presenter">by Mark Sujew</span>

Abstract: Contemporary software projects represent feats of ingenuity, seldom the work of a solitary software engineer. To enhance collaboration among developers in these projects, recent years have seen the introduction of several tools, such as Microsoft's Live Share or CodeTogether. Although these tools excel in their intended role, they are limited in their support for only a few select IDEs and lack extensibility.
This presentation aims to explain the need for a fresh approach to collaboration within the software engineering community, one rooted in genuine open-source principles. We will examine existing tool limitations and elaborate on our approach to addressing them. Additionally, we'll explore the conceptualization, implementation, and deployment of this innovative approach.

#### Server-side architecture for reactive analysis of domain models <span class="presenter">by Radimir Sorokin</span>

In the talk, we delve into the topic of facilitating projectional editing with semantic analysis in the context of web applications. In desktop applications like JetBrains MPS, document analysis is straightforward: upon opening an editor, an analysis is run in-process, promptly delivering results to the user screen. However, transitioning to web-based editors introduces complexities due to the necessity of remote analysis on the server, presenting its own set of challenges. In our talk, we outline our approach to conducting semantic document analysis for a projection editor on the server side. Notably, our method promotes reactive and incremental analysis, while preserving the analysis outcomes in a database.

#### Leveraging Machine Learning for Python Version Identification <span class="presenter">by Vadim Zaytsev</span>

Accurate identification of a programming language's version is crucial for maintaining code quality, ensuring compatibility, making informed development decisions. While classical AST-based and signature-based solutions perform well, they often fall short when dealing with the nuances of distinct language versions, producing erroneous results.

In this presentation, we explore the potential of machine learning techniques for precise Python version identification. Unlike traditional methods, machine learning is supposed to be able to discern intricate patterns in code and generalise from data, enabling rapid analysis of extensive codebases. To tackle this challenge effectively, our approach focuses on AST structures, operators, keywords and import statements.
We are currently engaged in training a machine learning model on diverse Python code snippets to distinguish between different versions. However, this journey presents its own set of complexities, including handling maximum token limits, disentangling Python's natural language-like syntax and addressing issues with unseen and noisy data.

We would like to share our experiences, insight, solutions and non-solutions to these challenges, paving the way for further research and community collaboration on the application of machine learning in source code analysis.

#### Human-centred explanation of rule-based systems in the legal domain <span class="presenter">by Suzan Zuurmond</span>

We present an innovative approach to enhance the transparency and user-friendliness of rule-based automated decision-making systems within the legal domain. Our research addresses the pressing need for human-centred explanations in such systems.

**Conceptual Framework**: To guide our efforts, we establish a conceptual framework encompassing essential internal components, namely content, communication, and adaptation, as well as critical external dependencies, including the system, recipient, and domain.

**Methodology**: We introduce a novel explanation method that leverages the power of a graph database. This database facilitates question-driven explanations, allowing us to tailor responses to individual users' inquiries. Furthermore, our method employs multimedia displays to augment user comprehension.

**Real-World Appl ication**: To demonstrate the practicality of our framework, we implement our explanation method within the operational context of the Dutch Tax and Customs Administration. This real-world application serves as a testbed for evaluating the effectiveness of our approach in a complex, domain-specific environment.

**Anticipated Outcomes**: While our research is ongoing, we anticipate that our method will lead to improved user understanding and trust in automated legal decision-making systems. Moreover, we believe that our approach has the potential to set a precedent for transparency and user-centricity in other automated systems beyond our specific case study.

This paper represents an essential step toward making automated decision-making systems more accessible and comprehensible to its users in the legal domain. Our multidisciplinary approach combines insights from law, social sciences, and artificial intelligence, offering a promising avenue for addressing the challenges posed by such systems.

#### Transformations to map concrete and abstract syntaxes in MPS <span class="presenter">by Wim Bast</span>

Wim Bast will give a demo of the usage of transformations to relate concrete and abstract syntaxes in MPS, using the DclareForMPS plugin. Wim will demonstrate that concrete syntax elements, and
model nodes, can both be first-class sitecance in a model-driven approach. The abstract syntax should be geared towards semantics, and not towards a particular concrete syntax. The transformations will give more freedom to differentiate the structure of the abstract syntax from the structure of the concrete syntax.

### Call for Presentations

We solicit talk proposals concerning the application, development, and innovation of language engineering. Topics of interest include, but are not limited to:
* Novel meta languages for language construction and composition
* Holistic approaches to language engineering that cross-cut multiple language aspects (e.g., abstract and concrete syntax, semantics, transformations) and/or integrate with program analysis, validation, testing, or other advanced techniques. 
* New language workbenches or novel extensions of existing language workbenches.
* Backend infrastructure of (web-based) language workbenches explaining solutions to collaboration, synchronization, or communication. 
* Industrial case studies: experience reports, large-scale evaluations, best practices, and human factors to adoption. 
* Low-Code / No-Code approaches using appropriate languages
  * Languages for describing and deriving digital twins
  * Languages for non-engineering issues, such as science, legal, social, or environmental sustainability issues
  * DSLs engineered on the basis of GPLs and GPMLs (general-purpose languages)

LangDev seeks presentations that demonstrate applied aspects of language engineering. Presentations explaining the theory behind language engineering are also welcome, but they need to showcase the practical applicability of the presented approaches. Presentations about preliminary or unfinished work are welcome.  

We encourage presenters to demonstrate their work with a **demo or live coding** over “just” showing slides. Additionally, we encourage speakers to accompany their presentations with a **reproduction package** that helps the participants to (easily) run the presented tools, experiment with them, or tweak benchmark experiments. This helps to create a lasting contribution. 

**Talk proposals should be submitted by September 15 via [langdev2023@belastingdienst.nl](mailto:langdev2023@belastingdienst.nl).** A proposal includes a title and a short abstract. As LangDev is an international meeting, the proposals and talks should be in English. In case the talk is accompanied by a demo, we encourage presenters to also provide a brief demo outline as part of the proposal. Presenters will have 30 minutes for their talks (25 min talk + 5 min Q&A). Longer slots of 45 minutes are available upon request. Presenters may choose to follow a traditional presentation style where the Q&A is at the end of the talk, or they may follow a chess timer-based style. Notifications about acceptance will be sent out by October 15. 

### Program Committee

Program Committee:
* Bernhard Rumpe, Software Engineering - RWTH Aachen
* Federico Tomassetti - Strumenta
* Wim Bast - Modeling Value Group
* Gert Veldhuijzen van Zanten - Belastingdienst (Dutch Tax Office)

All proposals will undergo reviewing by the program committee.  

###  Organization

In case you have any further questions, please contact: [langdev2023@belastingdienst.nl](mailto:langdev2023@belastingdienst.nl) 

Organizers (MDSE team of the Business Rules Management group):
* Joris van Aart
* Gert Veldhuijzen van Zanten 
* Arjan Oortgiese 
* Johan Blok 



---

LangDev'23 is organized by the MDSE team of the Business Rules Management group of the [Dutch Tax Office](http://www.belastingdienst.nl/).